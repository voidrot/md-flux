/* tslint:disable */
/* eslint-disable */
/**
 * The Confluence Cloud REST API v2
 * This document describes Confluence\'s v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CreatePage200Response,
  CreatePageRequest,
  MultiEntityResultPage,
  PageSortOrder,
  PrimaryBodyRepresentation,
  PrimaryBodyRepresentationSingle,
  UpdatePageRequest,
  UpdatePageTitleRequest,
} from '../models/index';
import {
    CreatePage200ResponseFromJSON,
    CreatePage200ResponseToJSON,
    CreatePageRequestFromJSON,
    CreatePageRequestToJSON,
    MultiEntityResultPageFromJSON,
    MultiEntityResultPageToJSON,
    PageSortOrderFromJSON,
    PageSortOrderToJSON,
    PrimaryBodyRepresentationFromJSON,
    PrimaryBodyRepresentationToJSON,
    PrimaryBodyRepresentationSingleFromJSON,
    PrimaryBodyRepresentationSingleToJSON,
    UpdatePageRequestFromJSON,
    UpdatePageRequestToJSON,
    UpdatePageTitleRequestFromJSON,
    UpdatePageTitleRequestToJSON,
} from '../models/index';

export interface CreatePageOperationRequest {
    createPageRequest: CreatePageRequest;
    embedded?: boolean;
    _private?: boolean;
    rootLevel?: boolean;
}

export interface DeletePageRequest {
    id: number;
    purge?: boolean;
    draft?: boolean;
}

export interface GetLabelPagesRequest {
    id: number;
    spaceId?: Array<number>;
    bodyFormat?: PrimaryBodyRepresentation;
    sort?: PageSortOrder;
    cursor?: string;
    limit?: number;
}

export interface GetPageByIdRequest {
    id: number;
    bodyFormat?: PrimaryBodyRepresentationSingle;
    getDraft?: boolean;
    status?: Array<GetPageByIdStatusEnum>;
    version?: number;
    includeLabels?: boolean;
    includeProperties?: boolean;
    includeOperations?: boolean;
    includeLikes?: boolean;
    includeVersions?: boolean;
    includeVersion?: boolean;
    includeFavoritedByCurrentUserStatus?: boolean;
    includeWebresources?: boolean;
    includeCollaborators?: boolean;
    includeDirectChildren?: boolean;
}

export interface GetPagesRequest {
    id?: Array<number>;
    spaceId?: Array<number>;
    sort?: PageSortOrder;
    status?: Array<GetPagesStatusEnum>;
    title?: string;
    bodyFormat?: PrimaryBodyRepresentation;
    subtype?: GetPagesSubtypeEnum;
    cursor?: string;
    limit?: number;
}

export interface GetPagesInSpaceRequest {
    id: number;
    depth?: GetPagesInSpaceDepthEnum;
    sort?: PageSortOrder;
    status?: Array<GetPagesInSpaceStatusEnum>;
    title?: string;
    bodyFormat?: PrimaryBodyRepresentation;
    cursor?: string;
    limit?: number;
}

export interface UpdatePageOperationRequest {
    id: number;
    updatePageRequest: UpdatePageRequest;
}

export interface UpdatePageTitleOperationRequest {
    id: number;
    updatePageTitleRequest: UpdatePageTitleRequest;
}

/**
 * 
 */
export class PageApi extends runtime.BaseAPI {

    /**
     * Creates a page in the space.  Pages are created as published by default unless specified as a draft in the status field. If creating a published page, the title must be specified.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the corresponding space. Permission to create a page in the space.
     * Create page
     */
    async createPageRaw(requestParameters: CreatePageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreatePage200Response>> {
        if (requestParameters['createPageRequest'] == null) {
            throw new runtime.RequiredError(
                'createPageRequest',
                'Required parameter "createPageRequest" was null or undefined when calling createPage().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['embedded'] != null) {
            queryParameters['embedded'] = requestParameters['embedded'];
        }

        if (requestParameters['_private'] != null) {
            queryParameters['private'] = requestParameters['_private'];
        }

        if (requestParameters['rootLevel'] != null) {
            queryParameters['root-level'] = requestParameters['rootLevel'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["write:page:confluence"]);
        }


        let urlPath = `/pages`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreatePageRequestToJSON(requestParameters['createPageRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreatePage200ResponseFromJSON(jsonValue));
    }

    /**
     * Creates a page in the space.  Pages are created as published by default unless specified as a draft in the status field. If creating a published page, the title must be specified.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the corresponding space. Permission to create a page in the space.
     * Create page
     */
    async createPage(requestParameters: CreatePageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreatePage200Response> {
        const response = await this.createPageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a page by id.  By default this will delete pages that are non-drafts. To delete a page that is a draft, the endpoint must be called on a  draft with the following param `draft=true`. Discarded drafts are not sent to the trash and are permanently deleted.  Deleting a page moves the page to the trash, where it can be restored later. To permanently delete a page (or \"purge\" it), the endpoint must be called on a **trashed** page with the following param `purge=true`.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the page and its corresponding space. Permission to delete pages in the space. Permission to administer the space (if attempting to purge).
     * Delete page
     */
    async deletePageRaw(requestParameters: DeletePageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deletePage().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['purge'] != null) {
            queryParameters['purge'] = requestParameters['purge'];
        }

        if (requestParameters['draft'] != null) {
            queryParameters['draft'] = requestParameters['draft'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["delete:page:confluence"]);
        }


        let urlPath = `/pages/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a page by id.  By default this will delete pages that are non-drafts. To delete a page that is a draft, the endpoint must be called on a  draft with the following param `draft=true`. Discarded drafts are not sent to the trash and are permanently deleted.  Deleting a page moves the page to the trash, where it can be restored later. To permanently delete a page (or \"purge\" it), the endpoint must be called on a **trashed** page with the following param `purge=true`.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the page and its corresponding space. Permission to delete pages in the space. Permission to administer the space (if attempting to purge).
     * Delete page
     */
    async deletePage(requestParameters: DeletePageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deletePageRaw(requestParameters, initOverrides);
    }

    /**
     * Returns the pages of specified label. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page and its corresponding space.
     * Get pages for label
     */
    async getLabelPagesRaw(requestParameters: GetLabelPagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MultiEntityResultPage>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getLabelPages().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['spaceId'] != null) {
            queryParameters['space-id'] = requestParameters['spaceId'];
        }

        if (requestParameters['bodyFormat'] != null) {
            queryParameters['body-format'] = requestParameters['bodyFormat'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["read:page:confluence"]);
        }


        let urlPath = `/labels/{id}/pages`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MultiEntityResultPageFromJSON(jsonValue));
    }

    /**
     * Returns the pages of specified label. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page and its corresponding space.
     * Get pages for label
     */
    async getLabelPages(requestParameters: GetLabelPagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MultiEntityResultPage> {
        const response = await this.getLabelPagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a specific page.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the page and its corresponding space.
     * Get page by id
     */
    async getPageByIdRaw(requestParameters: GetPageByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreatePage200Response>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getPageById().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['bodyFormat'] != null) {
            queryParameters['body-format'] = requestParameters['bodyFormat'];
        }

        if (requestParameters['getDraft'] != null) {
            queryParameters['get-draft'] = requestParameters['getDraft'];
        }

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['version'] != null) {
            queryParameters['version'] = requestParameters['version'];
        }

        if (requestParameters['includeLabels'] != null) {
            queryParameters['include-labels'] = requestParameters['includeLabels'];
        }

        if (requestParameters['includeProperties'] != null) {
            queryParameters['include-properties'] = requestParameters['includeProperties'];
        }

        if (requestParameters['includeOperations'] != null) {
            queryParameters['include-operations'] = requestParameters['includeOperations'];
        }

        if (requestParameters['includeLikes'] != null) {
            queryParameters['include-likes'] = requestParameters['includeLikes'];
        }

        if (requestParameters['includeVersions'] != null) {
            queryParameters['include-versions'] = requestParameters['includeVersions'];
        }

        if (requestParameters['includeVersion'] != null) {
            queryParameters['include-version'] = requestParameters['includeVersion'];
        }

        if (requestParameters['includeFavoritedByCurrentUserStatus'] != null) {
            queryParameters['include-favorited-by-current-user-status'] = requestParameters['includeFavoritedByCurrentUserStatus'];
        }

        if (requestParameters['includeWebresources'] != null) {
            queryParameters['include-webresources'] = requestParameters['includeWebresources'];
        }

        if (requestParameters['includeCollaborators'] != null) {
            queryParameters['include-collaborators'] = requestParameters['includeCollaborators'];
        }

        if (requestParameters['includeDirectChildren'] != null) {
            queryParameters['include-direct-children'] = requestParameters['includeDirectChildren'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["read:page:confluence"]);
        }


        let urlPath = `/pages/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreatePage200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a specific page.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the page and its corresponding space.
     * Get page by id
     */
    async getPageById(requestParameters: GetPageByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreatePage200Response> {
        const response = await this.getPageByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all pages. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to access the Confluence site (\'Can use\' global permission). Only pages that the user has permission to view will be returned.
     * Get pages
     */
    async getPagesRaw(requestParameters: GetPagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MultiEntityResultPage>> {
        const queryParameters: any = {};

        if (requestParameters['id'] != null) {
            queryParameters['id'] = requestParameters['id'];
        }

        if (requestParameters['spaceId'] != null) {
            queryParameters['space-id'] = requestParameters['spaceId'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['title'] != null) {
            queryParameters['title'] = requestParameters['title'];
        }

        if (requestParameters['bodyFormat'] != null) {
            queryParameters['body-format'] = requestParameters['bodyFormat'];
        }

        if (requestParameters['subtype'] != null) {
            queryParameters['subtype'] = requestParameters['subtype'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["read:page:confluence"]);
        }


        let urlPath = `/pages`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MultiEntityResultPageFromJSON(jsonValue));
    }

    /**
     * Returns all pages. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to access the Confluence site (\'Can use\' global permission). Only pages that the user has permission to view will be returned.
     * Get pages
     */
    async getPages(requestParameters: GetPagesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MultiEntityResultPage> {
        const response = await this.getPagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all pages in a space. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to access the Confluence site (\'Can use\' global permission) and \'View\' permission for the space. Only pages that the user has permission to view will be returned.
     * Get pages in space
     */
    async getPagesInSpaceRaw(requestParameters: GetPagesInSpaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MultiEntityResultPage>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getPagesInSpace().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['depth'] != null) {
            queryParameters['depth'] = requestParameters['depth'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['title'] != null) {
            queryParameters['title'] = requestParameters['title'];
        }

        if (requestParameters['bodyFormat'] != null) {
            queryParameters['body-format'] = requestParameters['bodyFormat'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["read:page:confluence"]);
        }


        let urlPath = `/spaces/{id}/pages`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MultiEntityResultPageFromJSON(jsonValue));
    }

    /**
     * Returns all pages in a space. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to access the Confluence site (\'Can use\' global permission) and \'View\' permission for the space. Only pages that the user has permission to view will be returned.
     * Get pages in space
     */
    async getPagesInSpace(requestParameters: GetPagesInSpaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MultiEntityResultPage> {
        const response = await this.getPagesInSpaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a page by id.  When the \"current\" version is updated, the provided body content is considered as the latest version. This latest body content will be attempted to be merged into the draft version through a content reconciliation algorithm. If two versions are significantly diverged,  the latest provided content may entirely override what was previously in the draft.   **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the page and its corresponding space. Permission to update pages in the space.
     * Update page
     */
    async updatePageRaw(requestParameters: UpdatePageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreatePage200Response>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updatePage().'
            );
        }

        if (requestParameters['updatePageRequest'] == null) {
            throw new runtime.RequiredError(
                'updatePageRequest',
                'Required parameter "updatePageRequest" was null or undefined when calling updatePage().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["write:page:confluence"]);
        }


        let urlPath = `/pages/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdatePageRequestToJSON(requestParameters['updatePageRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreatePage200ResponseFromJSON(jsonValue));
    }

    /**
     * Update a page by id.  When the \"current\" version is updated, the provided body content is considered as the latest version. This latest body content will be attempted to be merged into the draft version through a content reconciliation algorithm. If two versions are significantly diverged,  the latest provided content may entirely override what was previously in the draft.   **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the page and its corresponding space. Permission to update pages in the space.
     * Update page
     */
    async updatePage(requestParameters: UpdatePageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreatePage200Response> {
        const response = await this.updatePageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the title of a specified page.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the page and its corresponding space. Permission to update pages in the space.
     * Update page title
     */
    async updatePageTitleRaw(requestParameters: UpdatePageTitleOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreatePage200Response>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updatePageTitle().'
            );
        }

        if (requestParameters['updatePageTitleRequest'] == null) {
            throw new runtime.RequiredError(
                'updatePageTitleRequest',
                'Required parameter "updatePageTitleRequest" was null or undefined when calling updatePageTitle().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["write:page:confluence"]);
        }


        let urlPath = `/pages/{id}/title`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdatePageTitleRequestToJSON(requestParameters['updatePageTitleRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreatePage200ResponseFromJSON(jsonValue));
    }

    /**
     * Updates the title of a specified page.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the page and its corresponding space. Permission to update pages in the space.
     * Update page title
     */
    async updatePageTitle(requestParameters: UpdatePageTitleOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreatePage200Response> {
        const response = await this.updatePageTitleRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetPageByIdStatusEnum = {
    Current: 'current',
    Archived: 'archived',
    Trashed: 'trashed',
    Deleted: 'deleted',
    Historical: 'historical',
    Draft: 'draft'
} as const;
export type GetPageByIdStatusEnum = typeof GetPageByIdStatusEnum[keyof typeof GetPageByIdStatusEnum];
/**
 * @export
 */
export const GetPagesStatusEnum = {
    Current: 'current',
    Archived: 'archived',
    Deleted: 'deleted',
    Trashed: 'trashed'
} as const;
export type GetPagesStatusEnum = typeof GetPagesStatusEnum[keyof typeof GetPagesStatusEnum];
/**
 * @export
 */
export const GetPagesSubtypeEnum = {
    Live: 'live',
    Page: 'page'
} as const;
export type GetPagesSubtypeEnum = typeof GetPagesSubtypeEnum[keyof typeof GetPagesSubtypeEnum];
/**
 * @export
 */
export const GetPagesInSpaceDepthEnum = {
    All: 'all',
    Root: 'root'
} as const;
export type GetPagesInSpaceDepthEnum = typeof GetPagesInSpaceDepthEnum[keyof typeof GetPagesInSpaceDepthEnum];
/**
 * @export
 */
export const GetPagesInSpaceStatusEnum = {
    Current: 'current',
    Archived: 'archived',
    Deleted: 'deleted',
    Trashed: 'trashed'
} as const;
export type GetPagesInSpaceStatusEnum = typeof GetPagesInSpaceStatusEnum[keyof typeof GetPagesInSpaceStatusEnum];
